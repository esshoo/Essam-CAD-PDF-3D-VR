import * as THREE from "three";
import { Viewer2d } from "@x-viewer/core";
import {
  LocalDxfUploader,
  PdfLoaderPlugin,
  AxisGizmoPlugin,
  BottomBarPlugin,
  MeasurementPlugin,
  Viewer2dToolbarPlugin,
  MarkupPlugin,
  Settings2dPlugin,
  StatsPlugin,
  LayerManagerPlugin,
  ToolbarMenuId,
} from "@x-viewer/plugins";

export class CADViewerApp {
  constructor(containerId = "myCanvas", options = {}) {
    this.containerId = containerId;
    this.options = options || {};

    this.viewer = null;
    this.uploader = null;
    this.layerManager = null;

    // PDF state
    this._pdfPlugin = null;
    this._pdfPagerEl = null;
    this._pdfPagerSelect = null;
    this._pdfPagerLabel = null;
    this._pdfPageCount = 0;
    this._pdfCurrentPage = 1;

    // Fixers
    this._pdfFitTimer = null;
    this._fixInterval = null;
    
    // ‚úÖ ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑÿ¨ŸàÿØÿ© (ŸäÿØŸàŸä)
    this._useProgressiveMode = false; // ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä: ÿ¨ŸàÿØÿ© ÿπÿßŸÑŸäÿ© (ŸÑÿ≠ŸÑ ŸÖÿ¥ŸÉŸÑÿ© ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™)
  }

  async init() {
    const viewerCfg = {
      containerId: this.containerId,
      language: "en",
      enableSpinner: true,
      enableProgressBar: true,
      enableLayoutBar: true,
      enableLocalCache: false,
    };

    this.viewer = new Viewer2d(viewerCfg);

    // Fonts
    try {
      await this.viewer.setFont([
        "./libs/fonts/hztxt.shx",
        "./libs/fonts/simplex.shx",
        "./libs/fonts/arial.ttf",
        "./libs/fonts/helvetiker_regular.typeface.json",
        "./libs/fonts/Microsoft_YaHei.ttf",
        "./libs/fonts/Microsoft_YaHei_Regular.typeface.json",
      ]);
    } catch (e) {
      console.warn("Font loading warning:", e);
    }

    this._initPluginsFull();
    this._initUploader();
    this._initQualityToggle(); // ‚úÖ ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ

    console.log("System Ready.");
  }

  _initPluginsFull() {
    new AxisGizmoPlugin(this.viewer, { ignoreZAxis: true });
    new BottomBarPlugin(this.viewer);
    new MeasurementPlugin(this.viewer, { language: "en" });
    new MarkupPlugin(this.viewer);
    new Settings2dPlugin(this.viewer, { language: "en", visible: false });
    new StatsPlugin(this.viewer);

    const menuConfig = {
      [ToolbarMenuId.Layers]: {
        onActive: () => {
          if (!this.layerManager) this.layerManager = new LayerManagerPlugin(this.viewer);
          this.layerManager.setVisible(true);
        },
        onDeactive: () => {
          if (this.layerManager) this.layerManager.setVisible(false);
        },
      },
    };

    new Viewer2dToolbarPlugin(this.viewer, { menuConfig, language: "en" });
  }

  _initUploader() {
    const fileInput = document.getElementById("file-input");

    this.uploader = new LocalDxfUploader(this.viewer, fileInput);
    this.uploader.setPdfWorker("./libs/pdf/pdf.worker.min.js");

    this.uploader.onSuccess = () => {
      console.log("File Uploaded.");
      window.dispatchEvent(new CustomEvent("cad:file-loaded"));
    };

    this._patchUploaderPdfBehavior();
    this._patchUploaderDxfBehavior();
  }

  // ‚úÖ ÿ≤ÿ± ÿ®ÿ≥Ÿäÿ∑ ŸÑÿ™ÿ®ÿØŸäŸÑ ÿßŸÑŸàÿ∂ÿπ ŸäÿØŸàŸäÿßŸã
  _initQualityToggle() {
    const toggleBtn = document.createElement("button");
    toggleBtn.innerText = "‚ö° Quality: HIGH";
    Object.assign(toggleBtn.style, {
        position: "fixed",
        bottom: "10px",
        left: "10px",
        zIndex: "999999",
        padding: "8px 12px",
        background: "rgba(0, 200, 0, 0.8)", // ÿ£ÿÆÿ∂ÿ± ŸÑŸÑÿ¨ŸàÿØÿ© ÿßŸÑÿπÿßŸÑŸäÿ©
        color: "white",
        border: "none",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        fontSize: "12px",
        boxShadow: "0 2px 5px rgba(0,0,0,0.3)"
    });

    toggleBtn.onclick = () => {
        this._useProgressiveMode = !this._useProgressiveMode;
        if (this._useProgressiveMode) {
            toggleBtn.innerText = "üõ°Ô∏è Safety Mode (Multi-Page)";
            toggleBtn.style.background = "rgba(255, 140, 0, 0.8)"; // ÿ®ÿ±ÿ™ŸÇÿßŸÑŸä ŸÑŸÑÿ£ŸÖÿßŸÜ
        } else {
            toggleBtn.innerText = "‚ö° Quality: HIGH";
            toggleBtn.style.background = "rgba(0, 200, 0, 0.8)";
        }
        console.log("Mode switched to:", this._useProgressiveMode ? "Progressive (Safety)" : "Direct (High Quality)");
        alert(`ÿ™ŸÖ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ: ${this._useProgressiveMode ? "Ÿàÿ∂ÿπ ÿßŸÑÿ£ŸÖÿßŸÜ (ŸÑŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖÿ™ÿπÿØÿØÿ©)" : "Ÿàÿ∂ÿπ ÿßŸÑÿ¨ŸàÿØÿ© ÿßŸÑÿπÿßŸÑŸäÿ© (ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑŸàÿßÿ≠ÿØÿ©)"}.\nŸäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¢ŸÜ.`);
    };

    document.body.appendChild(toggleBtn);
  }

  _patchUploaderPdfBehavior() {
    const app = this;

    this.uploader.uploadSinglePdf = async function (file) {
      this.file = file;
      const fileUrl = URL.createObjectURL(file);
      
      // ŸÜÿπÿ™ŸÖÿØ ÿπŸÑŸâ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑŸäÿØŸàŸä ÿßŸÑÿ¢ŸÜ ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿßŸÑÿ™ÿÆŸÖŸäŸÜ
      const useProgressive = app._useProgressiveMode;
      console.log(`[Uploader] Starting PDF load. Mode: ${useProgressive ? 'Progressive' : 'High Quality'}`);

      let didFinalFit = false;
      const onProgress = (evt) => {
        try {
          if (!evt?.total) return;
          const p = Math.floor((evt.loaded * 100) / evt.total);
          console.log(`[Loading] ${p}%`);
          if (!didFinalFit && p >= 100) {
            didFinalFit = true;
            app._schedulePdfFit(150);
          }
        } catch (_) {}
      };

      try {
        app._stopContinuousFixer();

        app._pdfPlugin = new PdfLoaderPlugin(app.viewer, {
            font: app.viewer.getFontManager?.() || app.viewer.fontManager,
            pdfWorker: this.pdfWorker,
            // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÖÿÆÿ™ÿßÿ± ŸäÿØŸàŸäÿßŸã
            enableProgressiveLoad: useProgressive, 
            scale: useProgressive ? 2.0 : 3.0, 
        });

        const model = await app._pdfPlugin.loadAsync(
          { merge: true, src: fileUrl, modelId: file.name },
          onProgress
        );

        app.viewer.addModel(model);

        app._pdfPageCount = app._pdfPlugin.getPageCount?.() || 0;
        app._pdfCurrentPage = 1;
        app._ensurePdfPager(app._pdfPageCount);

        app._schedulePdfFit(300);
        app._tryFlattenCamera();

        // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ•ÿµŸÑÿßÿ≠ ÿßŸÑŸÖŸÜÿßÿ≥ÿ® ŸÑŸÑŸàÿ∂ÿπ ÿßŸÑŸÖÿÆÿ™ÿßÿ±
        if (useProgressive) {
            app._startContinuousFixer();
        } else {
            app._forceNoCulling(); 
        }

        this.onSuccess && this.onSuccess({});
      } catch (e) {
        console.info(e);
      }
    };
  }

  _patchUploaderDxfBehavior() {
    const app = this;
    this.uploader.uploadSingleDxf = async function (file) {
      const onProgress = () => {};
      try {
        app._stopContinuousFixer();
        const modelConfig = Object.assign({}, this.defaultModelConfig || { merge: true, src: "" }, {
            merge: true, src: URL.createObjectURL(file), modelId: file.name
        });
        await this.viewer.loadModel(modelConfig, onProgress);
        this.onSuccess && this.onSuccess({});
      } catch (e) {
        console.error(e);
        alert("ŸÅÿ¥ŸÑ ŸÅÿ™ÿ≠ ŸÖŸÑŸÅ CAD.");
      }
    };
    try { app.viewer?.enableRender?.(); } catch (_) {}
  }

  _ensurePdfPager(pageCount) {
    if (!pageCount || pageCount <= 1) {
      if (this._pdfPagerEl) this._pdfPagerEl.style.display = "none";
      return;
    }

    if (!this._pdfPagerEl) {
      const wrap = document.createElement("div");
      wrap.id = "pdf-pager";
      Object.assign(wrap.style, {
        position: "fixed",
        top: "80px", 
        right: "20px",
        zIndex: "999999",
        background: "rgba(0,0,0,0.55)",
        color: "#fff",
        padding: "8px 10px",
        borderRadius: "10px",
        display: "flex",
        gap: "8px",
        alignItems: "center",
        fontFamily: "Arial, sans-serif",
        fontSize: "12px",
        userSelect: "none",
      });

      const label = document.createElement("span"); label.textContent = "Page:"; wrap.appendChild(label);

      const btnPrev = document.createElement("button");
      btnPrev.textContent = "‚óÄ";
      Object.assign(btnPrev.style, this._pagerBtnStyle());
      btnPrev.onclick = async () => {
        const next = Math.max(1, (this._pdfCurrentPage || 1) - 1);
        await this._loadPdfPage(next);
      };
      wrap.appendChild(btnPrev);

      const sel = document.createElement("select");
      Object.assign(sel.style, { padding: "4px", borderRadius: "4px", background: "rgba(255,255,255,0.1)", color: "#fff", border:"1px solid #555" });
      sel.onchange = async () => { await this._loadPdfPage(parseInt(sel.value)); };
      wrap.appendChild(sel);

      const btnNext = document.createElement("button");
      btnNext.textContent = "‚ñ∂";
      Object.assign(btnNext.style, this._pagerBtnStyle());
      btnNext.onclick = async () => {
        const next = Math.min(this._pdfPageCount || 1, (this._pdfCurrentPage || 1) + 1);
        await this._loadPdfPage(next);
      };
      wrap.appendChild(btnNext);

      const info = document.createElement("span");
      wrap.appendChild(info);
      document.body.appendChild(wrap);
      this._pdfPagerEl = wrap;
      this._pdfPagerSelect = sel;
      this._pdfPagerLabel = info;
    }

    this._pdfPagerEl.style.display = "flex";
    this._pdfPagerSelect.innerHTML = "";
    for (let i = 1; i <= pageCount; i++) {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = String(i);
      if (i === (this._pdfCurrentPage || 1)) opt.selected = true;
      this._pdfPagerSelect.appendChild(opt);
    }
    this._pdfPagerLabel.textContent = `/ ${pageCount}`;
  }

  _pagerBtnStyle() {
    return { width: "28px", height: "24px", borderRadius: "6px", border: "1px solid rgba(255,255,255,0.25)", background: "rgba(255,255,255,0.12)", color: "#fff", cursor: "pointer", lineHeight: "22px" };
  }

  async _loadPdfPage(pageNo) {
    if (!this._pdfPlugin) return;
    pageNo = Math.max(1, Math.min(this._pdfPageCount || 1, pageNo));

    let didFinalFit = false;
    const onProgress = (evt) => { /* ... */ };

    await this._pdfPlugin.loadPage(pageNo, onProgress);
    
    this._pdfCurrentPage = pageNo;
    if (this._pdfPagerSelect) this._pdfPagerSelect.value = String(pageNo);
    this.viewer.enableRender?.();

    this._schedulePdfFit(260);
    this._tryFlattenCamera();
    
    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸàÿ∂ÿπ "ÿßŸÑÿ£ŸÖÿßŸÜ" ŸÖŸÅÿπŸÑÿßŸãÿå ÿ¥ÿ∫ŸÑ ÿßŸÑŸÖÿ±ÿßŸÇÿ®. Ÿàÿ•ŸÑÿßÿå ÿ•ÿµŸÑÿßÿ≠ ŸÅŸàÿ±Ÿä ŸÅŸÇÿ∑.
    if (this._useProgressiveMode) this._startContinuousFixer();
    else this._forceNoCulling();
  }

  _tryFlattenCamera() {
    try {
      const cam = this.viewer?.camera;
      if (cam) { cam.rotation.set(0, 0, 0); cam.up.set(0, 1, 0); }
      const controls = this.viewer?.controls;
      if (controls) { controls.enableRotate = false; controls.update(); }
    } catch (_) {}
  }

  _schedulePdfFit(delayMs = 200) {
    if (this._pdfFitTimer) clearTimeout(this._pdfFitTimer);
    this._pdfFitTimer = setTimeout(() => { this._fitPdfViewport(); }, delayMs);
  }

  _startContinuousFixer() {
    this._stopContinuousFixer();
    this._fixInterval = setInterval(() => { this._forceNoCulling(); }, 500);
    this._forceNoCulling();
  }

  _stopContinuousFixer() {
    if (this._fixInterval) { clearInterval(this._fixInterval); this._fixInterval = null; }
  }

  _forceNoCulling() {
    try {
      const scene = this.viewer.scene || (this.viewer.getScene && this.viewer.getScene());
      if (!scene) return;

      scene.traverse((obj) => {
        if (obj.isMesh || obj.isLine) {
          obj.frustumCulled = false;
          if (obj.material) {
             obj.material.transparent = true;
             obj.material.depthWrite = false; 
             obj.material.depthTest = true;
             
             if (obj.material.polygonOffset !== true) {
                 obj.material.polygonOffset = true;
                 obj.material.polygonOffsetFactor = -1.0;
                 obj.material.polygonOffsetUnits = -4.0;
                 obj.material.needsUpdate = true;
             }
          }
        }
      });
      if (this.viewer.enableRender) this.viewer.enableRender();
    } catch (_) {}
  }

  _fitPdfViewport() {
    try {
      this._forceNoCulling();
      if (!this._pdfPlugin) return;
      const box = this._pdfPlugin.getPdfViewport?.();
      if (!box) return;

      const center = new THREE.Vector3();
      const size = new THREE.Vector3();
      box.getCenter(center); box.getSize(size);

      const cam = this.viewer?.camera;
      if (!cam) return;
      cam.up.set(0, 1, 0);
      cam.near = 0.01; cam.far = 1e9;
      
      const el = document.getElementById(this.containerId);
      const w = el?.clientWidth || 1; const h = el?.clientHeight || 1;

      if (cam.isPerspectiveCamera) {
        const maxDim = Math.max(size.x, size.y);
        const fov = (cam.fov * Math.PI) / 180;
        const dist = (maxDim / 2) / Math.tan(fov / 2);
        cam.position.set(center.x, center.y, dist * 1.2);
        cam.lookAt(center);
      } else if (cam.isOrthographicCamera) {
        cam.position.set(center.x, center.y, cam.position.z || 1000);
        cam.lookAt(center);
        const zx = w / (size.x || 1); const zy = h / (size.y || 1);
        cam.zoom = Math.min(zx, zy) * 0.9;
      }
      cam.updateProjectionMatrix?.();
      
      const controls = this.viewer?.controls;
      if (controls) { controls.enableRotate = false; controls.update(); }
      this.viewer.enableRender?.();
    } catch (_) {}
  }

  openFileUpload() {
    if (this.uploader) this.uploader.openFileBrowserToUpload();
  }
}
